# SQLite初回実行時のOptimisticLockingFailureException回避

## エラーが発生する理由

このエラーは、バッチフレームワークが StepExecution レコードをデータベースに更新しようとした際に、そのレコードが存在しないために発生します。

### 楽観的ロックの仕組み
 - バッチフレームワークは、JobExecution や StepExecution といったメタデータレコードの更新に「楽観的ロック」という仕組みを使用しています。
 - これは、レコードに version というフィールドを持たせ、更新時にその version が読み込んだ時と同じであることを確認することで、他のプロセスによる同時更新を防ぐ手法です。

### 初回実行時の問題
 - SQLite の場合、初回実行時にはデータベースファイルが空であるか、バッチメタデータ用のテーブル（例: batch_step_execution）がまだ作成されていないか、あるいはテーブルはあってもレコードが一つも存在しない状態です。
 - migrateMetadataStep のようなステップが実行される際、そのステップ自身の実行状況を記録する StepExecution レコードが作成されます。
 - ステップの処理が完了した後、フレームワークは StepExecution レコードの最終状態（完了、失敗など）をデータベースに更新しようとします。
 - しかし、初回実行時には、この StepExecution レコードがまだデータベースに一度も挿入されていないため、更新対象のレコードが見つかりません。
 - 「with version 0 not found for update」というメッセージは、ID が一致し、かつバージョンが 0 のレコードを更新しようとしたが、そのようなレコードが見つからなかったことを示しています。これは、レコードがそもそも存在しない場合に発生する典型的な挙動です。

## 回避策

このエラーを回避するための根本的な解決策は、StepExecution レコードを更新する前に、必ずデータベースに挿入（保存）することです。

### ステップ実行開始時の初期保存 
 - StepExecution オブジェクトがメモリ上で作成された後、ステップのビジネスロジックが実行される直前に、その StepExecution レコードをデータベースに新規レコードとして挿入します。これにより、レコードが version 0 でデータベースに存在することが保証されます。
### その後の更新処理 
 - 初期保存が成功していれば、ステップの実行中に発生する状態変更（例: STARTED への更新、読み込み・書き込みカウントの更新、COMPLETED や FAILED への最終更新）は、既存のレコードに対して行われるため、楽観的ロックのチェックも正しく機能し、エラーは発生しなくなります。

## WAL (Write-Ahead Logging) の役割について

WAL モードは、SQLite の同時実行性とクラッシュリカバリを改善するための機能です。

 - WAL を有効にすると、書き込み操作がデータベースファイルをロックする時間が短縮され、読み込み操作と書き込み操作が同時に行えるようになります。
 - しかし、WAL は「レコードが存在しない状態で更新しようとする」という問題自体を解決するものではありません。WAL は、あくまで「存在するレコードへのアクセス競合」を緩和するものです。

したがって、この特定の「OptimisticLockingFailureException」エラーは、WAL の設定とは直接関係なく、StepExecution レコードの初期挿入が適切に行われているかどうかに依存します。

## 問題

SQLite環境での初回バッチ実行時（特にデータベースが空の状態）に、`TaskletStep 'migrateMetadataStep'`などのステップが`StepExecution`の最終状態を更新しようとした際に、`OptimisticLockingFailureException`が発生する。
これは、楽観的ロックの仕組みにおいて、更新対象の`StepExecution`レコードがデータベースにまだ存在しないために発生する。

## 解決策

`StepExecutor`がステップの実行を開始する際に、対応する`StepExecution`レコードをデータベースに初期保存（INSERT）するように変更する。これにより、後続の更新処理が常に既存のレコードに対して行われるようになり、`OptimisticLockingFailureException`の発生を回避する。

## 実装ステップ

1.  `pkg/batch/engine/step/batch_step_executor.go` ファイルを開く。
2.  `BatchStepExecutor` 型の `ExecuteStep` メソッドの冒頭に、引数として受け取った `stepExecution` オブジェクトを `s.jobRepository.SaveStepExecution(ctx, stepExecution)` を使用してデータベースに保存する処理を追加する。
3.  初期保存が成功した場合、既存のステップ実行ロジック（`step.Execute(...)`）に進む。
4.  初期保存が失敗した場合、適切なエラーログを出力し、エラーを返却する。
