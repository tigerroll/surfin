# 1. 設計原則 (Design Principles)

Surfin Batch Frameworkは、以下の主要な原則に基づいて設計されています。これらの原則は、フレームワークの拡張性、保守性、およびクラウドネイティブ環境への適合性を保証します。

## 1.1. 責務の分離 (Separation of Concerns)

Jobの定義（JSL）、実行フロー（Job Runner）、ビジネスロジック（Item/Tasklet）、永続化（Repository/Adapter）の各層を明確に分離しています。これにより、各コンポーネントは単一の責務に集中し、変更の影響範囲を最小限に抑えます。

## 1.2. 依存性逆転の原則 (Dependency Inversion Principle, DIP)

フレームワークのコアロジック（`pkg/batch/core`）は、具体的な実装（例: GORM、Prometheus、特定のDBドライバ）ではなく、抽象化されたインターフェース（`port` パッケージ内のインターフェース）に依存します。
これらのインターフェースは、フレームワークの「契約」として機能します。

具体的な実装は `adapter` 層や `infrastructure` 層に配置され、Go Fxによる依存性注入（DI）を通じてコアコンポーネントに提供されます。
これにより、コアロジックは特定のインフラストラクチャ実装に縛られず、テスト容易性や将来的な技術変更への対応が容易になります。

## 1.3. 拡張性 (Extensibility)

ユーザーが独自のコンポーネントを容易にプラグインできる構造を採用しています。

*   **カスタムコンポーネント**: `ItemReader`, `ItemProcessor`, `ItemWriter`, `Tasklet` はすべてインターフェースであり、ユーザーは独自のビジネスロジックを実装し、JSLで参照できます。
    これにより、フレームワークのコアを変更することなく、アプリケーション固有の要件に対応できます。
*   **DBProvider**: 新しいデータベースタイプ（例: Redshift, BigQuery）を追加する場合、`surfin/pkg/batch/core/adapter.DBProvider` インターフェースを実装するだけで、コアの永続化ロジックを変更する必要はありません。
    これにより、新しいデータベースシステムへの対応が容易になり、インフラストラクチャの選択肢が広がります。

## 1.4. トランザクション境界の明確化

トランザクション管理は、ビジネスロジック（Item/Tasklet）から完全に分離されています。これは、責務の分離とDIPの原則に基づき、ビジネスロジックと永続化層の密結合を防ぐための重要な設計です。

*   **StepExecutor**: `TaskletStep` の実行において、`StepExecutor` がトランザクション境界（`REQUIRED`, `REQUIRES_NEW`, `NESTED` など）を確立します。
*   **ChunkStep**: `ChunkStep` は、チャンク処理の単位で内部的にトランザクションを管理します。
